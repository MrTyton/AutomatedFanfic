name: Cache Cleanup

on:
  schedule:
    # Run weekly on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Perform a dry run (show what would be deleted without actually deleting)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      keep_versions:
        description: 'Number of recent versions to keep (default: 5)'
        required: false
        default: '5'
        type: string

permissions:
  actions: write  # Required to delete GitHub Actions cache
  contents: read  # Required to read repository content

env:
  IMAGE_REPO: mrtyton
  IMAGE_NAME: automated-ffdl

jobs:
  cleanup_github_actions_cache:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup GitHub CLI
        run: |
          # GitHub CLI is pre-installed on GitHub runners
          gh --version

      - name: Cleanup GitHub Actions Cache
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "üßπ Starting GitHub Actions cache cleanup..."

          # Get all cache entries
          echo "Fetching cache entries..."
          CACHES=$(gh api repos/${{ github.repository }}/actions/caches --paginate)

          if [ "$DRY_RUN" = "true" ]; then
            echo "üîç DRY RUN MODE - No actual deletions will be performed"
          fi

          # Get cache entries older than 60 days
          SIXTY_DAYS_AGO=$(date -d '60 days ago' -u +%Y-%m-%dT%H:%M:%SZ)
          echo "Targeting caches older than: $SIXTY_DAYS_AGO"

          # Parse and delete old caches
          echo "$CACHES" | jq -r --arg cutoff "$SIXTY_DAYS_AGO" '
            .actions_caches[] |
            select(.created_at < $cutoff) |
            "\(.id) \(.key) \(.created_at) \(.size_in_bytes)"
          ' | while read -r cache_id cache_key created_at size_bytes; do
            size_mb=$((size_bytes / 1024 / 1024))
            echo "üì¶ Cache: $cache_key (ID: $cache_id, Created: $created_at, Size: ${size_mb}MB)"

            if [ "$DRY_RUN" = "true" ]; then
              echo "   [DRY RUN] Would delete cache ID: $cache_id"
            else
              echo "   üóëÔ∏è  Deleting cache ID: $cache_id"
              gh api --method DELETE repos/${{ github.repository }}/actions/caches/$cache_id || {
                echo "   ‚ùå Failed to delete cache ID: $cache_id"
              }
            fi
          done

          # Show summary
          if [ "$DRY_RUN" = "true" ]; then
            echo "‚úÖ Dry run completed - no actual changes made"
          else
            echo "‚úÖ GitHub Actions cache cleanup completed"
          fi

  cleanup_docker_hub_tags:
    runs-on: ubuntu-latest
    needs: cleanup_github_actions_cache
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Get current and recent versions
        id: versions
        run: |
          KEEP_VERSIONS=${{ github.event.inputs.keep_versions || '5' }}
          CURRENT_VERSION=$(cat release-versions/latest.txt)

          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "keep_versions=$KEEP_VERSIONS" >> $GITHUB_OUTPUT

          echo "Current version: $CURRENT_VERSION"
          echo "Will keep the latest $KEEP_VERSIONS versions"

      - name: Setup Docker Hub API access
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USER }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "üê≥ Starting Docker Hub cleanup..."

          if [ "$DRY_RUN" = "true" ]; then
            echo "üîç DRY RUN MODE - No actual deletions will be performed"
          fi

          # Get Docker Hub token
          echo "Authenticating with Docker Hub..."
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"$DOCKERHUB_USER\",\"password\":\"$DOCKERHUB_PASSWORD\"}" \
            https://hub.docker.com/v2/users/login/)

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token')
          if [ "$TOKEN" = "null" ] || [ -z "$TOKEN" ]; then
            echo "‚ùå Failed to authenticate with Docker Hub"
            exit 1
          fi

          echo "‚úÖ Successfully authenticated with Docker Hub"
          echo "DOCKER_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: Get Docker Hub tags and cleanup
        env:
          DOCKER_TOKEN: ${{ env.DOCKER_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
          CURRENT_VERSION: ${{ steps.versions.outputs.current_version }}
          KEEP_VERSIONS: ${{ steps.versions.outputs.keep_versions }}
        run: |
          echo "üìã Fetching Docker Hub tags..."

          # Get all tags from Docker Hub with pagination
          ALL_TAGS=""
          PAGE=1
          while true; do
            TAGS_RESPONSE=$(curl -s -H "Authorization: JWT $DOCKER_TOKEN" \
              "https://hub.docker.com/v2/repositories/${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}/tags/?page_size=100&page=$PAGE")

            if [ $? -ne 0 ]; then
              echo "‚ùå Failed to fetch tags from Docker Hub"
              exit 1
            fi

            # Check if we have results
            RESULTS_COUNT=$(echo "$TAGS_RESPONSE" | jq -r '.results | length')
            if [ "$RESULTS_COUNT" -eq 0 ]; then
              break
            fi

            # Append results to our collection
            if [ -z "$ALL_TAGS" ]; then
              ALL_TAGS="$TAGS_RESPONSE"
            else
              ALL_TAGS=$(echo "$ALL_TAGS" | jq --argjson new_results "$(echo "$TAGS_RESPONSE" | jq '.results')" '.results += $new_results')
            fi

            # Check if there's a next page
            NEXT_PAGE=$(echo "$TAGS_RESPONSE" | jq -r '.next // empty')
            if [ -z "$NEXT_PAGE" ] || [ "$NEXT_PAGE" = "null" ]; then
              break
            fi

            PAGE=$((PAGE + 1))
          done

          echo "Found $(echo "$ALL_TAGS" | jq -r '.results | length') total tags"

          # Parse tags and identify what to keep vs delete
          echo "$ALL_TAGS" | jq -r '.results[] | "\(.name) \(.last_updated)"' | while read -r tag_name last_updated; do

            # Always preserve the latest tag
            if [ "$tag_name" = "latest" ]; then
              echo "üîí Keeping: $tag_name (latest tag - never delete)"
              continue
            fi

            # Always preserve semantic version tags (e.g., 1.2.35, 2.5.2)
            if echo "$tag_name" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "üîí Keeping: $tag_name (semantic version - never delete)"
              continue
            fi

            # Always preserve architecture-specific version tags (e.g., 1.2.35-amd64, 2.5.2-arm64)
            if echo "$tag_name" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+-(amd64|arm64)$'; then
              echo "üîí Keeping: $tag_name (architecture version tag - never delete)"
              continue
            fi

            # Now handle cache and temporary tags - only delete if older than 60 days
            IS_CACHE_TAG=false
            TAG_DESCRIPTION=""

            if echo "$tag_name" | grep -qE '^cache-'; then
              IS_CACHE_TAG=true
              TAG_DESCRIPTION="cache tag"
            elif echo "$tag_name" | grep -qE '^(main|master|develop|dev)-'; then
              IS_CACHE_TAG=true
              TAG_DESCRIPTION="branch tag"
            elif echo "$tag_name" | grep -qE '^pr-[0-9]+'; then
              IS_CACHE_TAG=true
              TAG_DESCRIPTION="PR tag"
            elif echo "$tag_name" | grep -qE '^[a-f0-9]{7,40}$'; then
              IS_CACHE_TAG=true
              TAG_DESCRIPTION="commit hash tag"
            elif echo "$tag_name" | grep -qE '^(alpha|beta|rc|test|staging)'; then
              IS_CACHE_TAG=true
              TAG_DESCRIPTION="pre-release tag"
            fi

            if [ "$IS_CACHE_TAG" = "false" ]; then
              echo "ü§î Unknown tag pattern: $tag_name - keeping to be safe"
              continue
            fi

            # Check if cache/temporary tag is older than 60 days
            if command -v date >/dev/null 2>&1; then
              # Convert last_updated to epoch time for comparison
              if date -d "$last_updated" >/dev/null 2>&1; then
                TAG_DATE=$(date -d "$last_updated" +%s)
                CUTOFF_DATE=$(date -d '60 days ago' +%s)

                if [ "$TAG_DATE" -gt "$CUTOFF_DATE" ]; then
                  echo "üïê Keeping: $tag_name ($TAG_DESCRIPTION updated within 60 days: $last_updated)"
                  continue
                fi
              else
                echo "ü§î Cannot parse date for $tag_name - keeping to be safe"
                continue
              fi
            else
              echo "ü§î Date command not available - keeping $tag_name to be safe"
              continue
            fi

            # This cache/temporary tag should be deleted
            echo "üóëÔ∏è  Target for deletion: $tag_name ($TAG_DESCRIPTION, last updated: $last_updated)"

            if [ "$DRY_RUN" = "true" ]; then
              echo "   [DRY RUN] Would delete $TAG_DESCRIPTION: $tag_name"
            else
              echo "   üóëÔ∏è  Deleting $TAG_DESCRIPTION: $tag_name"
              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: JWT $DOCKER_TOKEN" \
                "https://hub.docker.com/v2/repositories/${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}/tags/$tag_name/")

              if [ $? -eq 0 ]; then
                echo "   ‚úÖ Successfully deleted: $tag_name"
              else
                echo "   ‚ùå Failed to delete: $tag_name"
              fi
            fi
          done

          # Show summary
          if [ "$DRY_RUN" = "true" ]; then
            echo "‚úÖ Docker Hub dry run completed - no actual changes made"
          else
            echo "‚úÖ Docker Hub cleanup completed"
          fi

  cleanup_summary:
    runs-on: ubuntu-latest
    needs: [cleanup_github_actions_cache, cleanup_docker_hub_tags]
    if: always()
    steps:
      - name: Cleanup Summary
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "üßπ Cache Cleanup Summary"
          echo "======================="

          if [ "$DRY_RUN" = "true" ]; then
            echo "Mode: üîç DRY RUN (no actual deletions performed)"
          else
            echo "Mode: üóëÔ∏è  LIVE CLEANUP (deletions performed)"
          fi

          echo ""
          echo "GitHub Actions Cleanup:"
          echo "- Removes cache entries older than 60 days"
          echo ""
          echo "Docker Hub Cleanup:"
          echo "- Removes cache/temporary tags older than 60 days"
          echo ""
          echo "Always Preserved:"
          echo "- ‚úÖ 'latest' tag"
          echo "- ‚úÖ All semantic version tags (e.g., 1.2.35, 2.5.2)"
          echo "- ‚úÖ All architecture version tags (e.g., 1.2.35-amd64, 2.5.2-arm64)"
          echo ""
          echo "Cleanup Targets (if >60 days old):"
          echo "- üóëÔ∏è  cache-* tags (build cache layers)"
          echo "- üóëÔ∏è  branch tags (main-, master-, develop-, etc.)"
          echo "- üóëÔ∏è  PR tags (pr-123, etc.)"
          echo "- üóëÔ∏è  commit hash tags"
          echo "- üóëÔ∏è  pre-release tags (alpha, beta, rc, test, staging)"

          if [ "${{ needs.cleanup_github_actions_cache.result }}" = "success" ]; then
            echo "‚úÖ GitHub Actions cache cleanup: Completed"
          else
            echo "‚ùå GitHub Actions cache cleanup: Failed or skipped"
          fi

          if [ "${{ needs.cleanup_docker_hub_tags.result }}" = "success" ]; then
            echo "‚úÖ Docker Hub tags cleanup: Completed"
          else
            echo "‚ùå Docker Hub tags cleanup: Failed or skipped"
          fi

          echo ""
          echo "Next scheduled cleanup: $(date -d 'next sunday 3:00' '+%Y-%m-%d %H:%M UTC')"
