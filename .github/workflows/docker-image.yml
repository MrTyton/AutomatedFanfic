name: Publish Docker Image

on:
  # Trigger automatically AFTER "Python application CI" completes successfully on master
  workflow_run:
    workflows: ["Python application CI"]
    types:
      - completed
    branches:
      - master
  # Triggered explicitly by update-dependencies after successful CI
  workflow_call:
    inputs:
      commit_sha:
        description: "The specific commit SHA to checkout and build (from update-dependencies)"
        required: true # Required when called
        type: string
    secrets: # Define secrets that can be passed by the caller
      DOCKERHUB_USER:
        required: true
      DOCKERHUB_PASSWORD:
        required: true
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, tag, or SHA to build (default: master)"
        required: false
        default: "master"

permissions:
  contents: write # Required to create releases/tags

env:
  IMAGE_REPO: mrtyton
  IMAGE_NAME: automated-ffdl

jobs:
  # Debug job - always runs first to confirm workflow is called
  debug_workflow_trigger:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ” DEBUG - Docker Workflow Called Successfully
        run: |
          echo "======================================================================"
          echo "ðŸŽ‰ SUCCESS: docker-image.yml workflow is running!"
          echo "======================================================================"
          echo "Event details:"
          echo "  github.event_name: ${{ github.event_name }}"
          echo "  github.event.workflow_run.conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo ""
          echo "Input parameters:"
          echo "  commit_sha: ${{ inputs.commit_sha || 'not provided' }}"
          echo ""
          echo "If you see this message, the Docker workflow trigger is working!"
          echo "======================================================================"

  # Build matrix for parallel architecture builds
  build_matrix:
    # Run if dispatched OR if called OR if workflow_run succeeded OR if scheduled (but we'll check for version changes later)
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || github.event_name == 'schedule' || github.event.workflow_run.conclusion == 'success'
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
        runner: [ubuntu-latest, ubuntu-24.04-arm]
        exclude:
          - platform: linux/amd64
            runner: ubuntu-24.04-arm
          - platform: linux/arm64
            runner: ubuntu-latest
    runs-on: ${{ matrix.runner }}
    outputs:
      commit_sha: ${{ steps.get_sha.outputs.commit_sha }}
      specific_version: ${{ steps.set_versions.outputs.specific_version }}
      calibre_version: ${{ steps.set_versions.outputs.calibre_version }}
      fanficfare_version: ${{ steps.set_versions.outputs.fanficfare_version }}
      should_build: ${{ steps.should_build.outputs.build }}
    steps:
      # Determine the commit SHA based on trigger type
      - name: Determine Commit SHA
        id: get_sha
        run: |
          COMMIT_TO_CHECKOUT=""
          EVENT_NAME="${{ github.event_name }}"
          INPUT_SHA="${{ inputs.commit_sha || '' }}"

          echo "Event Name: $EVENT_NAME"
          echo "Input SHA (from inputs context): $INPUT_SHA"

          if [ -n "$INPUT_SHA" ]; then
            COMMIT_TO_CHECKOUT="$INPUT_SHA"
            echo "Using commit SHA from input: $COMMIT_TO_CHECKOUT"
          elif [ "$EVENT_NAME" == "workflow_run" ]; then
            COMMIT_TO_CHECKOUT="${{ github.event.workflow_run.head_sha }}"
            echo "Using commit SHA from workflow_run event: $COMMIT_TO_CHECKOUT"

            if [ -z "$COMMIT_TO_CHECKOUT" ]; then
              echo "::warning::workflow_run.head_sha is empty, falling back to github.sha"
              COMMIT_TO_CHECKOUT="${{ github.sha }}"
            fi
          elif [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            DISPATCH_REF="${{ github.event.inputs.ref || github.ref_name }}"
            echo "Attempting checkout for workflow_dispatch (ref: $DISPATCH_REF)..."
            git clone $GITHUB_SERVER_URL/$GITHUB_REPOSITORY .
            git checkout $DISPATCH_REF
            COMMIT_TO_CHECKOUT=$(git rev-parse HEAD)
            echo "Using commit SHA for workflow_dispatch (ref: $DISPATCH_REF): $COMMIT_TO_CHECKOUT"
          else
             echo "::error::Unknown event type '$EVENT_NAME' or unable to determine SHA."
             exit 1
          fi

          if [ -z "$COMMIT_TO_CHECKOUT" ]; then
             echo "::error::Failed to determine a valid commit SHA."
             exit 1
          fi

          echo "Final commit_sha=$COMMIT_TO_CHECKOUT"
          echo "commit_sha=$COMMIT_TO_CHECKOUT" >> $GITHUB_OUTPUT

      # Checkout the specific commit determined above
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_sha.outputs.commit_sha }}
          fetch-depth: 0

      # Check if the specific file was changed (only relevant for workflow_run)
      - name: Check for changes in latest.txt (for workflow_run)
        id: check_file
        if: github.event_name == 'workflow_run'
        run: |
          echo "Current HEAD commit: $(git rev-parse HEAD)"
          echo "Expected commit SHA: ${{ steps.get_sha.outputs.commit_sha }}"

          echo "Recent commit history:"
          git log --oneline -5

          echo "Files changed in current commit:"
          git diff --name-only HEAD~1 HEAD || echo "Could not get diff"

          # Check if latest.txt changed in the current commit
          if git diff --name-only HEAD~1 HEAD | grep -q '^release-versions/latest\.txt$'; then
            echo "Changes detected in release-versions/latest.txt"
            echo "changed=true" >> $GITHUB_OUTPUT

            echo "Changes in release-versions/latest.txt:"
            git diff HEAD~1 HEAD -- 'release-versions/latest.txt' || echo "Could not show diff"
          else
            echo "No changes detected in release-versions/latest.txt"
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # Debug step to show build decision and set output
      - name: Make build decision
        id: should_build
        run: |
          echo "Build decision factors:"
          echo "  Event: ${{ github.event_name }}"
          echo "  File changed (workflow_run only): ${{ steps.check_file.outputs.changed }}"

          SHOULD_BUILD="false"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_BUILD="true"
            echo "  Decision: BUILD (manual trigger)"
          elif [ "${{ github.event_name }}" == "workflow_call" ]; then
            SHOULD_BUILD="true"
            echo "  Decision: BUILD (called from update-dependencies)"
          elif [ "${{ github.event_name }}" == "workflow_run" ] && [ "${{ steps.check_file.outputs.changed }}" == "true" ]; then
            SHOULD_BUILD="true"
            echo "  Decision: BUILD (workflow_run with version file changes)"
          else
            echo "  Decision: SKIP (no version changes detected)"
          fi

          echo "  Final decision: $SHOULD_BUILD"
          echo "build=$SHOULD_BUILD" >> $GITHUB_OUTPUT

          if [ "$SHOULD_BUILD" == "true" ]; then
            echo "Proceeding with Docker build..."
          else
            echo "Skipping Docker build - no version changes detected"
          fi

      # Extract platform identifier for cache scoping
      - name: Extract platform info
        if: steps.should_build.outputs.build == 'true'
        id: platform
        run: |
          PLATFORM_PAIR=${{ matrix.platform }}
          PLATFORM_ARCH=${PLATFORM_PAIR##*/}
          echo "arch=${PLATFORM_ARCH}" >> $GITHUB_OUTPUT
          echo "pair=${PLATFORM_PAIR}" >> $GITHUB_OUTPUT

      # Set up QEMU
      - name: Set up QEMU
        if: steps.should_build.outputs.build == 'true'
        uses: docker/setup-qemu-action@v3

      # Setup Docker Buildx
      - name: Setup Docker Buildx
        if: steps.should_build.outputs.build == 'true'
        id: buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host

      # Determine versions by reading files
      - name: Determine Versions and Tags from Files
        if: steps.should_build.outputs.build == 'true'
        id: set_versions
        run: |
          # Specific Version
          if [ -s "release-versions/latest.txt" ]; then
            SPECIFIC_VERSION=$(cat release-versions/latest.txt)
            echo "Read specific_version from file: $SPECIFIC_VERSION"
          else
            echo "::error::release-versions/latest.txt is missing or empty."
            exit 1
          fi
          # Calibre Version
          if [ -s "release-versions/calibre.txt" ]; then
             CALIBRE_VERSION=$(cat release-versions/calibre.txt)
             echo "Read calibre_version from file: $CALIBRE_VERSION"
          else
             echo "::error::release-versions/calibre.txt is missing or empty."
             exit 1
          fi
          # FanFicFare Version
          if [ -s "release-versions/fanficfare.txt" ]; then
             FANFICFARE_VERSION=$(cat release-versions/fanficfare.txt)
             echo "Read fanficfare_version from file: $FANFICFARE_VERSION"
          else
             echo "::error::release-versions/fanficfare.txt is missing or empty."
             exit 1
          fi
          # Set environment variables for build args and tags
          echo "SPECIFIC_VERSION=$SPECIFIC_VERSION" >> $GITHUB_ENV
          echo "CALIBRE_VERSION=$CALIBRE_VERSION" >> $GITHUB_ENV
          echo "FANFICFARE_VERSION=$FANFICFARE_VERSION" >> $GITHUB_ENV

          # Set outputs for the merge job
          echo "specific_version=$SPECIFIC_VERSION" >> $GITHUB_OUTPUT
          echo "calibre_version=$CALIBRE_VERSION" >> $GITHUB_OUTPUT
          echo "fanficfare_version=$FANFICFARE_VERSION" >> $GITHUB_OUTPUT

          # Create platform-specific tags
          PLATFORM_TAG="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${SPECIFIC_VERSION}-${{ steps.platform.outputs.arch }}"
          echo "PLATFORM_TAG=$PLATFORM_TAG" >> $GITHUB_ENV
          echo "Platform-specific tag: $PLATFORM_TAG"

      - name: Print image tags and versions
        if: steps.should_build.outputs.build == 'true'
        run: |
          echo "Commit SHA: ${{ steps.get_sha.outputs.commit_sha }}"
          echo "Platform: ${{ steps.platform.outputs.pair }}"
          echo "Architecture: ${{ steps.platform.outputs.arch }}"
          echo "Specific Version: ${{ env.SPECIFIC_VERSION }}"
          echo "Calibre Version: ${{ env.CALIBRE_VERSION }}"
          echo "FanFicFare Version: ${{ env.FANFICFARE_VERSION }}"
          echo "Platform Tag: ${{ env.PLATFORM_TAG }}"

      - name: Login to DockerHub
        if: steps.should_build.outputs.build == 'true'
        uses: docker/login-action@v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push platform-specific image
        if: steps.should_build.outputs.build == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ env.PLATFORM_TAG }}
          # Optimized cache strategy for dependency-focused updates
          # Order matters: most specific caches first, then fallbacks
          cache-from: |
            type=gha,scope=calibre-${{ env.CALIBRE_VERSION }}-${{ steps.platform.outputs.arch }}
            type=gha,scope=fanficfare-${{ env.FANFICFARE_VERSION }}-${{ steps.platform.outputs.arch }}
            type=gha,scope=stable-deps-${{ steps.platform.outputs.arch }}
            type=gha,scope=buildkit-${{ steps.platform.outputs.arch }}
            type=gha,scope=calibre-fallback-${{ steps.platform.outputs.arch }}
            type=gha,scope=fanficfare-fallback-${{ steps.platform.outputs.arch }}
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-calibre-${{ env.CALIBRE_VERSION }}-${{ steps.platform.outputs.arch }}
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-fanficfare-${{ env.FANFICFARE_VERSION }}-${{ steps.platform.outputs.arch }}
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-stable-${{ steps.platform.outputs.arch }}
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-${{ steps.platform.outputs.arch }}
          cache-to: |
            type=gha,scope=calibre-${{ env.CALIBRE_VERSION }}-${{ steps.platform.outputs.arch }},mode=max
            type=gha,scope=fanficfare-${{ env.FANFICFARE_VERSION }}-${{ steps.platform.outputs.arch }},mode=max
            type=gha,scope=stable-deps-${{ steps.platform.outputs.arch }},mode=max
            type=gha,scope=buildkit-${{ steps.platform.outputs.arch }},mode=max
            type=gha,scope=calibre-fallback-${{ steps.platform.outputs.arch }},mode=max
            type=gha,scope=fanficfare-fallback-${{ steps.platform.outputs.arch }},mode=max
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-calibre-${{ env.CALIBRE_VERSION }}-${{ steps.platform.outputs.arch }},mode=max
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-fanficfare-${{ env.FANFICFARE_VERSION }}-${{ steps.platform.outputs.arch }},mode=max
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-stable-${{ steps.platform.outputs.arch }},mode=max
            type=registry,ref=${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:cache-${{ steps.platform.outputs.arch }},mode=max
          build-args: |
            VERSION=${{ env.SPECIFIC_VERSION }}
            CALIBRE_RELEASE=${{ env.CALIBRE_VERSION }}
            FANFICFARE_VERSION=${{ env.FANFICFARE_VERSION }}
            BUILDKIT_INLINE_CACHE=1

      # Store platform digest for manifest creation
      - name: Export platform digest
        if: steps.should_build.outputs.build == 'true'
        run: |
          mkdir -p /tmp/digests
          DIGEST=$(docker buildx imagetools inspect ${{ env.PLATFORM_TAG }} --format '{{.Manifest.Digest}}')
          echo "Platform digest: $DIGEST"
          echo "$DIGEST" > /tmp/digests/${{ steps.platform.outputs.arch }}

      - name: Upload platform digest
        if: steps.should_build.outputs.build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: digest-${{ steps.platform.outputs.arch }}
          path: /tmp/digests/${{ steps.platform.outputs.arch }}

  # Merge job to create multi-platform manifest and release
  merge_and_release:
    runs-on: ubuntu-latest
    needs: build_matrix
    if: always() && needs.build_matrix.result == 'success' && needs.build_matrix.outputs.should_build == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.build_matrix.outputs.commit_sha }}
          fetch-depth: 0

      - name: Download platform digests
        uses: actions/download-artifact@v5
        with:
          pattern: digest-*
          merge-multiple: true
          path: /tmp/digests

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3.6.0
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      # Use versions from build matrix job outputs instead of reading files
      - name: Set Versions from Build Matrix Outputs
        id: set_versions
        run: |
          SPECIFIC_VERSION="${{ needs.build_matrix.outputs.specific_version }}"
          CALIBRE_VERSION="${{ needs.build_matrix.outputs.calibre_version }}"
          FANFICFARE_VERSION="${{ needs.build_matrix.outputs.fanficfare_version }}"

          echo "Using version from build job: $SPECIFIC_VERSION"
          echo "Using Calibre version from build job: $CALIBRE_VERSION"
          echo "Using FanFicFare version from build job: $FANFICFARE_VERSION"

          echo "SPECIFIC_VERSION=$SPECIFIC_VERSION" >> $GITHUB_ENV
          echo "CALIBRE_VERSION=$CALIBRE_VERSION" >> $GITHUB_ENV
          echo "FANFICFARE_VERSION=$FANFICFARE_VERSION" >> $GITHUB_ENV

          # Create final tags
          TAGS="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${SPECIFIC_VERSION},${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:latest"
          echo "TAGS=$TAGS" >> $GITHUB_ENV
          echo "CALIBRE_VERSION=$CALIBRE_VERSION" >> $GITHUB_ENV
          echo "FANFICFARE_VERSION=$FANFICFARE_VERSION" >> $GITHUB_ENV

          # Create final tags
          TAGS="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${SPECIFIC_VERSION},${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:latest"
          echo "TAGS=$TAGS" >> $GITHUB_ENV

      - name: Create and push multi-platform manifest
        run: |
          # Create manifest list combining both platform images
          AMD64_TAG="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${{ env.SPECIFIC_VERSION }}-amd64"
          ARM64_TAG="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${{ env.SPECIFIC_VERSION }}-arm64"

          # Verify that both platform images exist before creating manifest
          echo "Verifying AMD64 image exists..."
          docker buildx imagetools inspect $AMD64_TAG || { echo "AMD64 image not found: $AMD64_TAG"; exit 1; }

          echo "Verifying ARM64 image exists..."
          docker buildx imagetools inspect $ARM64_TAG || { echo "ARM64 image not found: $ARM64_TAG"; exit 1; }

          echo "Both platform images verified. Creating manifest for version ${{ env.SPECIFIC_VERSION }}"
          docker buildx imagetools create -t ${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${{ env.SPECIFIC_VERSION }} \
            $AMD64_TAG $ARM64_TAG

          echo "Creating manifest for latest tag"
          docker buildx imagetools create -t ${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:latest \
            $AMD64_TAG $ARM64_TAG

      # Updated step to generate filtered changelog including requirements.txt and excluding bot commits
      - name: Generate Changelog
        id: generate_changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Needed for fetch
          CURRENT_COMMIT_SHA: ${{ needs.build_matrix.outputs.commit_sha }}
        run: |
          echo "Fetching tags..."
          # Fetch tags and full history needed for log between tags
          # Ensure fetch-depth is sufficient in checkout or unshallow here
          # git fetch --tags --unshallow --force || git fetch --tags --force # Already done by fetch-depth: 0

          # Get the latest tag that looks like a version (e.g., v1.2.3) excluding the one we might create
          PREVIOUS_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | grep -v "v${{ env.SPECIFIC_VERSION }}$" | head -n 1)

          # Debugging logs
          echo "PREVIOUS_TAG for changelog: $PREVIOUS_TAG"
          echo "CURRENT_COMMIT_SHA for changelog: $CURRENT_COMMIT_SHA"
          echo "Raw git log (pre-filtering) for relevant files between $PREVIOUS_TAG and $CURRENT_COMMIT_SHA:"
          git log ${PREVIOUS_TAG}..${CURRENT_COMMIT_SHA} --pretty=format:'* %s (%h) - Author: %an' -- '*.py' 'root/app/*.py' 'Dockerfile' 'requirements.txt' || echo "Git log command failed or returned no output."
          echo "--- End of raw git log ---"

          CHANGELOG_ENTRIES=""
          # Define bot author names (multiple variations)
          BOT_PATTERNS="github-actions\[bot\]|dependabot\[bot\]|renovate\[bot\]"

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Found previous tag: $PREVIOUS_TAG. Generating filtered changelog since then."
            # Get commits since the previous tag affecting relevant files, excluding bot commits
            # Use more specific paths instead of ** glob pattern for better compatibility
            COMMITS=$(git log ${PREVIOUS_TAG}..${CURRENT_COMMIT_SHA} --pretty=format:'%s (%h)|%an' -- '*.py' 'root/app/*.py' 'Dockerfile' 'requirements.txt' | grep -v -E "${BOT_PATTERNS}" | cut -d'|' -f1 | sed 's/^/* /' || echo "")
            if [ -n "$COMMITS" ]; then
              CHANGELOG_ENTRIES="\n\n**Relevant Changes since ${PREVIOUS_TAG}:**\n${COMMITS}"
            else
              CHANGELOG_ENTRIES="\n\nNo relevant non-bot code changes (Python/Dockerfile/requirements.txt) detected since ${PREVIOUS_TAG}."
            fi
          else
            echo "No previous version tag found. Listing all relevant commits for initial release."
            # List all commits up to the current one affecting relevant files, excluding bot commits
            COMMITS=$(git log ${CURRENT_COMMIT_SHA} --pretty=format:'%s (%h)|%an' -- '*.py' 'root/app/*.py' 'Dockerfile' 'requirements.txt' | grep -v -E "${BOT_PATTERNS}" | cut -d'|' -f1 | sed 's/^/* /' || echo "")
            if [ -n "$COMMITS" ]; then
              CHANGELOG_ENTRIES="\n\n**Relevant Commits in this release:**\n${COMMITS}"
            else
              # Added a message for the initial release case with no relevant commits
              CHANGELOG_ENTRIES="\n\nNo relevant non-bot code changes (Python/Dockerfile/requirements.txt) detected in this initial release scope."
            fi
          fi

          # Set the output, escaping for multiline
          echo "changelog_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${CHANGELOG_ENTRIES}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Generated Changelog Body:"
          echo -e "${CHANGELOG_ENTRIES}" # Print for debugging using echo -e

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ env.SPECIFIC_VERSION }}
          name: Release v${{ env.SPECIFIC_VERSION }}
          body: |
            Automated release for version ${{ env.SPECIFIC_VERSION }}.
            Built from commit: ${{ needs.build_matrix.outputs.commit_sha }}
            Includes Calibre version: ${{ env.CALIBRE_VERSION }}
            Includes FanFicFare version: ${{ env.FANFICFARE_VERSION }}${{ steps.generate_changelog.outputs.changelog_body }}

          draft: false
          prerelease: false

      # Optional: Add a step to indicate skipping if the file didn't change on workflow_run
      - name: Skipped build on workflow_run
        if: github.event_name == 'workflow_run'
        run: echo "Docker build completed successfully from commit ${{ needs.build_matrix.outputs.commit_sha }}."
