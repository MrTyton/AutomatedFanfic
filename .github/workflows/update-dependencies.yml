name: Update Dependencies and Run CI

on:
  schedule:
    - cron: '0 23 * * *' # Every day at 11pm UTC
  workflow_dispatch:

permissions:
  contents: write # Needed to commit changes and read repository files
  actions: write # Needed to call other workflows

jobs:
  # First job: Check dependencies and commit if needed
  check_and_update:
    runs-on: ubuntu-latest
    outputs:
      # Output commit SHA if changes were made - use verified SHA as fallback
      commit_sha: ${{ steps.verify_commit.outputs.verified_sha || steps.commit_changes.outputs.commit_long_sha }}
      # Output whether latest.txt was updated specifically (for potential future use, not strictly needed now)
      latest_updated: ${{ steps.update_latest_txt.outputs.version-changed }}
      # Additional output to ensure we trigger builds when updates are found
      changes_detected: ${{ steps.check_updates.outputs.any_changed }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # Read current versions needed later if no update occurs
      - name: Read current Calibre version
        id: read_calibre
        run: echo "version=$(cat release-versions/calibre.txt)" >> $GITHUB_OUTPUT

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-update-deps-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-update-deps-
            ${{ runner.os }}-pip-

      - name: Check for dependency updates
        id: check_updates
        run: |
          echo "Checking dependency versions..."

          # Initialize change flags
          echo "fff_changed=false" >> $GITHUB_OUTPUT
          echo "calibre_changed=false" >> $GITHUB_OUTPUT
          echo "any_changed=false" >> $GITHUB_OUTPUT
          echo "fff_new_version=" >> $GITHUB_OUTPUT
          echo "calibre_new_version=" >> $GITHUB_OUTPUT

          # Read current versions
          CURRENT_FFF_VERSION=$(cat release-versions/fanficfare.txt)
          CURRENT_CALIBRE_VERSION=$(cat release-versions/calibre.txt)

          # Validate files exist and have content
          if [ ! -f "release-versions/fanficfare.txt" ] || [ -z "$CURRENT_FFF_VERSION" ]; then
            echo "::error::fanficfare.txt not found or empty"
            exit 1
          fi

          if [ ! -f "release-versions/calibre.txt" ] || [ -z "$CURRENT_CALIBRE_VERSION" ]; then
            echo "::error::calibre.txt not found or empty"
            exit 1
          fi

          echo "Current FanFicFare version: $CURRENT_FFF_VERSION"
          echo "Current Calibre version: $CURRENT_CALIBRE_VERSION"

          # Check FanFicFare version
          echo "Fetching FanFicFare version information..."
          FFF_INDEX_URL="https://test.pypi.org/simple/fanficfare/"
          FFF_PAGE=$(curl -sSfL "$FFF_INDEX_URL" 2>/dev/null)

          if [ $? -ne 0 ] || [ -z "$FFF_PAGE" ]; then
            echo "::error::Failed to fetch FanFicFare index from $FFF_INDEX_URL"
            exit 1
          fi

          LATEST_FFF_VERSION=$(echo "$FFF_PAGE" | grep -oP 'fanficfare-\K[0-9.]+(?=\.tar\.gz)' | sort -V | tail -n 1)

          if [ -z "$LATEST_FFF_VERSION" ]; then
            echo "::error::Could not determine the latest FanFicFare version"
            exit 1
          fi

          echo "Latest FanFicFare version: $LATEST_FFF_VERSION"

          if [ "$LATEST_FFF_VERSION" != "$CURRENT_FFF_VERSION" ]; then
            echo "FanFicFare update detected: $CURRENT_FFF_VERSION -> $LATEST_FFF_VERSION"
            echo "$LATEST_FFF_VERSION" > release-versions/fanficfare.txt
            echo "fff_changed=true" >> $GITHUB_OUTPUT
            echo "fff_new_version=$LATEST_FFF_VERSION" >> $GITHUB_OUTPUT
          else
            echo "FanFicFare is up to date"
          fi

          # Check Calibre version
          echo "Fetching Calibre version information..."
          if ! command -v jq &> /dev/null; then
            echo "::error::jq is not available"
            exit 1
          fi

          LATEST_RELEASE_URL="https://api.github.com/repos/kovidgoyal/calibre/releases/latest"
          LATEST_RELEASE_INFO=$(curl -sSfL -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3+json" "$LATEST_RELEASE_URL")

          if [ -z "$LATEST_RELEASE_INFO" ]; then
            echo "::error::Failed to fetch latest Calibre release info"
            exit 1
          fi

          LATEST_CALIBRE_TAG=$(echo "$LATEST_RELEASE_INFO" | jq -r '.tag_name')
          if [ "$LATEST_CALIBRE_TAG" == "null" ] || [ -z "$LATEST_CALIBRE_TAG" ]; then
            echo "::error::Could not parse tag_name from Calibre release info"
            exit 1
          fi

          LATEST_CALIBRE_VERSION=${LATEST_CALIBRE_TAG#v} # Remove leading 'v'
          echo "Latest Calibre version: $LATEST_CALIBRE_VERSION (tag: $LATEST_CALIBRE_TAG)"

          if [ "$LATEST_CALIBRE_VERSION" != "$CURRENT_CALIBRE_VERSION" ]; then
            echo "Calibre update detected: $CURRENT_CALIBRE_VERSION -> $LATEST_CALIBRE_VERSION"
            echo "$LATEST_CALIBRE_VERSION" > release-versions/calibre.txt
            echo "calibre_changed=true" >> $GITHUB_OUTPUT
            echo "calibre_new_version=$LATEST_CALIBRE_VERSION" >> $GITHUB_OUTPUT
          else
            echo "Calibre is up to date"
          fi

          # Set combined flag
          if [ "$LATEST_FFF_VERSION" != "$CURRENT_FFF_VERSION" ] || [ "$LATEST_CALIBRE_VERSION" != "$CURRENT_CALIBRE_VERSION" ]; then
            echo "any_changed=true" >> $GITHUB_OUTPUT
            echo "Updates detected, will proceed with version bump"
          else
            echo "No updates detected"
          fi

      - name: Update latest.txt if any changes were made
        id: update_latest_txt
        if: steps.check_updates.outputs.any_changed == 'true'
        uses: ./.github/actions/bump-version
        with:
          bump-type: 'patch'
          reason: 'dependency'

      - name: Update version in fanficdownload.py
        if: steps.update_latest_txt.outputs.version-changed == 'true'
        run: |
          echo "âœ… Version updated by bump-version action"
          echo "Old version: ${{ steps.update_latest_txt.outputs.old-version }}"
          echo "New version: ${{ steps.update_latest_txt.outputs.new-version }}"

          # Verification that the action worked correctly
          echo "Verification:"
          grep "__version__" root/app/fanficdownload.py

      - name: Prepare Commit Message
        id: prepare_commit
        # This step now depends on the output of the modified update_latest_txt step
        if: steps.update_latest_txt.outputs.version-changed == 'true'
        run: |
          COMMIT_MSG="Automated Dependency Updates (v${{ steps.update_latest_txt.outputs.new-version }})" # Add new version here
          if [ "${{ steps.check_updates.outputs.fff_changed }}" == "true" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n\n- FanFicFare updated to ${{ steps.check_updates.outputs.fff_new_version }}"
          fi
          if [ "${{ steps.check_updates.outputs.calibre_changed }}" == "true" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n\n- Calibre updated to ${{ steps.check_updates.outputs.calibre_new_version }}"
          fi
          # Escape newlines for the commit action
          echo "commit_message<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit changes
        id: commit_changes
        # This step also depends on the output of the modified update_latest_txt step
        if: steps.update_latest_txt.outputs.version-changed == 'true'
        uses: EndBug/add-and-commit@v9
        with:
          author_name: github-actions[bot]
          author_email: github-actions[bot]@users.noreply.github.com
          message: ${{ steps.prepare_commit.outputs.commit_message }}
          # Ensure latest.txt is committed along with dependency files
          add: 'release-versions/latest.txt release-versions/fanficfare.txt release-versions/calibre.txt root/app/fanficdownload.py'

      - name: Verify commit and set output
        id: verify_commit
        if: steps.update_latest_txt.outputs.version-changed == 'true'
        run: |
          echo "Commit step outputs:"
          echo "  committed: ${{ steps.commit_changes.outputs.committed }}"
          echo "  commit_long_sha: ${{ steps.commit_changes.outputs.commit_long_sha }}"
          echo "  commit_sha: ${{ steps.commit_changes.outputs.commit_sha }}"

          # Verify the commit exists
          COMMIT_SHA="${{ steps.commit_changes.outputs.commit_long_sha }}"
          if [ -n "$COMMIT_SHA" ]; then
            echo "Commit created successfully: $COMMIT_SHA"
            echo "commit_verified=true" >> $GITHUB_OUTPUT
            echo "verified_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          else
            echo "::warning::Commit step did not produce a SHA, using current HEAD"
            CURRENT_SHA=$(git rev-parse HEAD)
            echo "Current HEAD: $CURRENT_SHA"
            echo "commit_verified=false" >> $GITHUB_OUTPUT
            echo "verified_sha=$CURRENT_SHA" >> $GITHUB_OUTPUT
          fi

          # Debug outputs for Docker workflow
          echo "DEBUG: Job outputs that will be set:"
          echo "  changes_detected: ${{ steps.check_updates.outputs.any_changed }}"
          echo "  commit_sha: $COMMIT_SHA"
          echo "  latest_updated: ${{ steps.update_latest_txt.outputs.version-changed }}"

      - name: Notify if no changes were committed (Should not happen with default token)
        if: steps.update_latest_txt.outputs.version-changed == 'true' && steps.commit_changes.outputs.commit_long_sha == ''
        run: |
            echo "::warning::Commit step was skipped or failed unexpectedly."
            # exit 1 # Consider removing exit 1 if it's just a warning

      - name: Notify if no updates were found
        if: steps.update_latest_txt.outputs.version-changed != 'true'
        run: echo "No updates were found for FanFicFare or Calibre."

  # Second job: Run CI by calling the reusable workflow
  run_ci:
    needs: check_and_update
    # Only run if changes were detected (commit_sha will always be set if changes detected)
    if: needs.check_and_update.outputs.changes_detected == 'true'
    uses: ./.github/workflows/python-app.yml
    with:
      # Pass the commit SHA that was created
      commit_sha: ${{ needs.check_and_update.outputs.commit_sha }}
    secrets: inherit # Inherit secrets if python-app ever needs them

  # Third job: Build Docker - directly depend on both jobs
  build_docker:
    needs: [check_and_update, run_ci]
    # Only run if changes detected AND commit SHA exists (CI success is guaranteed by dependency)
    if: needs.check_and_update.outputs.changes_detected == 'true' && needs.check_and_update.outputs.commit_sha != ''
    uses: ./.github/workflows/docker-image.yml
    with:
      commit_sha: ${{ needs.check_and_update.outputs.commit_sha }}
    secrets: inherit # Pass all secrets to the called workflow
